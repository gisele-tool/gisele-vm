# Start expects a label on top of the stack. It forks a new child process and schedules
# it for running at that label
start:   fork
         save
         pop

# Run starts running the current prog at its program counter.
run:     self
         get :pc
         then                       # enqueue instruction at program counter
         get :input
         flip                       # [ Prog, [ input... ] ] -> [ [ input... ], Prog ]
         push []
         set :input
         save
         pop
         unfold                     # [ input... ]

# Resume expects an input array on the stack. It fetches the current Prog and schedules
# it with the given input
resume:  self                       # take the current Prog
         push :enacter              #
         set :waitfor               #
         flip                       # [ input, prog ] -> [ prog, input ]
         set :input                 # prog.input = input
         save
         pop

# Given a Prog on the stack, simply saves it.
#
# INPUT:  [ Prog ] (aka `peek`)
# OUTPUT: [ ]
# PRE:    - `peek` should have been modified
# POST:   - `peek` is now saved
#
save_it: save
         pop

# Given a label on the stack, schedule the current Prog for execution there. The effective
# execution will only take place when the Prog will be selected for running.
#
# INPUT:  [ `at` ]
# OUTPUT: [ ]
# PRE:    - `at` must be a valid label
# POST:   - the current Prog is scheduled and its program counter set to `at` (and it is
#           saved)
#         - its waiting list is empty
#
schedule_at: self                       # [ pc, Prog ]
             flip                       # [ Prog, pc ]
             set :pc                    # [ Prog ]
             push :enacter              # [ Prog, :enacter ]
             set :waitfor               # [ Prog ]
             push {}                    # [ Prog, {} ]
             set :waitlist              # [ Prog ]
             then :save_it              # [ ]

# Given an event Hash on the stack. Registers it as waitlist. Unschedule the current prog
# for continuation at :react.
#
# INPUT:  [ `events` ]
# OUTPUT: [ ]
# PRE:    - `events` should be a valid waitlist
# POST:   - the current Prog sleeps at :react.
#         - its waitlist has been set to `events`
#
listen:  self                       # [ events, Prog ]
         flip                       # [ Prog, events ]
         set  :waitlist             # [ Prog ]
         push :world                # [ Prog, :world ]
         set  :waitfor              # [ Prog ]
         push :react                # [ Prog, :react ]
         set  :pc                   # [ Prog ]
         then :save_it              # [ ]

# Given an event on the stack, get the current Prog, check if it waits for this particular
# event. If yes, schedule the Prog as specified in its wait list. Otherwise, return to
# sleep.
#
# INPUT:  [ `event` ]
# OUTPUT: [ ]
# PRE:    - the current Prog should be waiting for events (in its waitlist)
# POST:   - if `event` is waited for, the current Prog is scheduled at the corresponding
#           location.
#         - otherwise, the current Prog falls alsleep (program counter unchanged)
#
react:   self                       # [ event, Prog ]
         getr :waitlist             # [ event, waitlist ]
         flip                       # [ waitlist, event ]
         getr                       # [ pc/nil ]
         ifenil                     #
         pop                        # [ ]
         then :schedule_at          # [ ]

# Fork a list of children at specified locations. Wait for joining them at a label
# `joinat` specified through the stack as well.
#
# INPUT:  [ joinat, [ forkat... ] ]
# OUTPUT: [ Prog ]  (the current prog)
# PRE:    - `joinat` is an existing label
#         - `forkat` is an array of existing labels.
# POST:   - a child Prog has been created for each label in `forkat`
#         - those children are all scheduled
#         - the current Prog waits for them all at `joinat` (not scheduled)
#
fork:    forka                      # [ joinat, [ Prog, ... ] ]
         savea                      # [ joinat, [ puid, ... ] ]
         self                       # [ joinat, [ puid, ... ], Prog ]
         flip                       # [ joinat, Prog, [ puid, ... ] ]
         set :waitlist              # [ joinat, Prog ]
         flip                       # [ Prog, joinat ]
         set :pc                    # [ Prog ]
         push :children             # [ Prog, :children ]
         set :waitfor               # [ Prog ]
         then :save_it              # [ ]

# Given a Hash of events, if the waitlist of the current prog is empty, schedule execution
# at the label associated to the `wake` event. Otherwise simply return asleep.
#
# INPUT:  [ {:wake => `wakeat`} ] (aka `events`)
# OUTPUT: [ ]
# PRE:    - `events` must include a :wake key
#         - `wakeat` must be an existing label
# POST:   - if the waitlist of the current prog is empty, it is scheduled at `wakeat`
#         - if ... is not empty, it is unscheduled (program counter unchanged)
#
join:    self                       # [ {evt...}, Prog ]
         getr :waitlist             # [ {evt...}, waitlist ]
         push []
         send :size                 # [ {evt...}, size ]
         ifezero
         push :wake
         push :wait                 # [ {evt...}, size, wake/wait ]
         flip                       # [ {evt...}, wake/wait, size ]
         pop                        # [ {evt...}, wake/wait ]
         get                        # [ {evt...}, label/nil ]
         flip                       # [ label/nil, {evt...} ]
         pop                        # [ label/nil ]
         ifenil                     # ...
         pop                        # [ ]
         then :schedule_at          # [ ]

# Expects a Prog on the stack (typically the parent). Remove the current puid from its
# waitlist and schedule it.
#
# INPUT:  [ Prog ]  (aka peek)
# OUTPUT: [ ]
# PRE:    - the current `puid` should be a key in `peek`'s waitlist
# POST:   - `peek`'s waitlist no longer contains an entry for `puid`
#         - `peek` is scheduled
#
notify_it:  get :waitlist              # [ Prog, waitlist ]
            puid                       # [ Prog, waitlist, puid ]
            del                        # [ Prog, waitlist ]
            set :waitlist              # [ Prog ]
            push :enacter              # [ Prog, :enacter ]
            set :waitfor               # [ Prog ]
            then :save_it              # [ ]

# End the current Prog then notify its parent through notify_it.
#
# INPUT:  [ ]
# OUTPUT: [ ]
# PRE:    - the current Prog should not be ended
# POST:   - the program counter of the current Prog is -1
# =>      - its waitfor attribute has been set to :none
#         - its parent has been notified, if any (@see notify_it)
#
notify:     self                       # [ Prog ]
            push -1                    # [ Prog, -1 ]
            set :pc                    # [ Prog ]
            push :none                 # [ Prog, :none ]
            set :waitfor               # [ Prog ]
            save                       # [ puid ]
            pop                        # [ ]
            parent                     # [ Prog/nil ]
            ifenil
            pop                        # [ ]
            then :notify_it            # [ ]
