# Start expects a label on top of the stack. It forks a new child process and schedules
# it for running at that label
start:   fork
         save
         pop

# Run starts running the current prog at its program counter.
run:     self
         get :pc
         then                       # enqueue instruction at program counter
         get :input
         flip                       # [ Prog, [ input... ] ] -> [ [ input... ], Prog ]
         push []
         set :input
         save
         pop
         unfold                     # [ input... ]

# Resume expects an input array on the stack. It fetches the current Prog and schedules
# it with the given input
resume:  self                       # take the current Prog
         schedule                   # schedule it
         flip                       # [ input, prog ] -> [ prog, input ]
         set :input                 # prog.input = input
         save
         pop

# Puts the current Prog on the stack. Unschedules and saves it.
sleepit: unschedule
         save
         pop
sleep:   self
         then :sleepit
