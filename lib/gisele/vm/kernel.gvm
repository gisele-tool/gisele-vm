# Start expects a label on top of the stack. It forks a new child process and schedules
# it for running at that label
start:   fork
         save
         pop

# Run starts running the current prog at its program counter.
run:     self
         get :pc
         then                       # enqueue instruction at program counter
         get :input
         flip                       # [ Prog, [ input... ] ] -> [ [ input... ], Prog ]
         push []
         set :input
         save
         pop
         unfold                     # [ input... ]

# Resume expects an input array on the stack. It fetches the current Prog and schedules
# it with the given input
resume:  self                       # take the current Prog
         schedule                   # schedule it
         flip                       # [ input, prog ] -> [ prog, input ]
         set :input                 # prog.input = input
         save
         pop

# Given a label on the stack, schedule the current Prog for execution there.
# The effective execution will only take place when the Prog will be selected
# for running.
schedat: self                       # [ pc, Prog ]
         flip                       # [ Prog, pc ]
         set :pc                    # [ Prog ]
         schedule                   # [ Prog ]
         push {}                    # [ Prog, {} ]
         set :waitlist              # [ Prog ]
         save                       # [ puid ]
         pop                        # [ ]

# Puts the current Prog on the stack. Unschedules and saves it.
sleepit: unschedule
         save
         pop
sleep:   self
         then :sleepit

# Given an event Hash on the stack. Registers it as waitlist. Unschedule the
# current prog for continuation at :react.
listen:  self                       # [ events, Prog ]
         flip                       # [ Prog, events ]
         set  :waitlist             # [ Prog ]
         push :react                # [ Prog, :react ]
         set  :pc                   # [ Prog ]
         then :sleepit

# Given an event on the stack. Get the current Prog. Check if it waits for this
# particular event. If yes, schedule the Prog as specified in its wait list.
# Otherwise, return to sleep.
react:   self                       # [ event, Prog ]
         getr :waitlist             # [ event, waitlist ]
         flip                       # [ waitlist, event ]
         getr                       # [ pc/nil ]
         ifenil                     # ...
         then :sleep
         then :schedat

# Expects a label `joinat` and an array `forkat` of labels on the stack. Fork one
# child for each label in `forkat` and save them. Wait for forked children at `at`.
#                                   # [ joinat, [ forkat... ] ]
fork:    forka                      # [ joinat, [ Prog, ... ] ]
         savea                      # [ joinat, [ puid, ... ] ]
         self                       # [ joinat, [ puid, ... ], Prog ]
         flip                       # [ joinat, Prog, [ puid, ... ] ]
         set :waitlist              # [ joinat, Prog ]
         flip                       # [ Prog, joinat ]
         set :pc                    # [ Prog ]
         then :sleepit

# Expects an Hash `evt` of events. If the waitlist of the current prog is empty,
# schedule execution at `wake` in this event map. Otherwise simply returns asleep.
#                                   # [ {evt...} ]
join:    self                       # [ {evt...}, Prog ]
         getr :waitlist             # [ {evt...}, waitlist ]
         push []
         send :size                 # [ {evt...}, size ]
         ifezero
         push :wake
         push :wait                 # [ {evt...}, size, wake/wait ]
         flip                       # [ {evt...}, wake/wait, size ]
         pop                        # [ {evt...}, wake/wait ]
         get                        # [ {evt...}, label/nil ]
         flip                       # [ label/nil, {evt...} ]
         pop                        # [ label/nil ]
         ifenil                     # ...
         then :sleep
         then :schedat

# Expects a Prog on the stack (typically the parent). Remove the current puid from its
# waitlist and schedule it.
#
# INPUT:  [ Prog ]  (aka peek)
# OUTPUT: [ ]
# PRE:    - the current `puid` should be a key in `peek`'s waitlist
# POST:   - `peek`'s waitlist no longer contains an entry for `puid`
#         - `peek` is scheduled
#
notify_it:  get :waitlist              # [ Prog, waitlist ]
            puid                       # [ Prog, waitlist, puid ]
            del                        # [ Prog, waitlist ]
            set :waitlist              # [ Prog ]
            schedule                   # [ Prog ]
            save                       # [ puid ]
            pop                        # [ ]

# End the current Prog then notify its parent through notify_it.
#
# INPUT:  [ ]
# OUTPUT: [ ]
# PRE:    - the current Prog should not be ended
# POST:   - the program counter of the current Prog is -1
#         - its parent has been notified, if any (@see notify_it)
#
notify:     end                        # [ Prog ]
            save                       # [ puid ]
            pop                        # [ ]
            parent                     # [ Prog/nil ]
            ifenil
            pop                        # [ ]
            then :notify_it            # [ ]
