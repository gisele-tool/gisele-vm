# Start expects a label on top of the stack. It forks a new child process and schedules
# it for running at that label
start:   fork
         save
         pop

# Run starts running the current prog at its program counter.
run:     self
         get :pc
         then                       # enqueue instruction at program counter
         get :input
         flip                       # [ Prog, [ input... ] ] -> [ [ input... ], Prog ]
         push []
         set :input
         save
         pop
         unfold                     # [ input... ]

# Resume expects an input array on the stack. It fetches the current Prog and schedules
# it with the given input
resume:  self                       # take the current Prog
         schedule                   # schedule it
         flip                       # [ input, prog ] -> [ prog, input ]
         set :input                 # prog.input = input
         save
         pop

# Given a label on the stack, schedule the current Prog for execution there.
# The effective execution will only take place when the Prog will be selected
# for running.
schedat: self                       # [ pc, Prog ]
         flip                       # [ Prog, pc ]
         set :pc                    # [ Prog ]
         schedule                   # [ Prog ]
         push {}                    # [ Prog, {} ]
         set :waitlist              # [ Prog ]
         save                       # [ puid ]
         pop                        # [ ]

# Puts the current Prog on the stack. Unschedules and saves it.
sleepit: unschedule
         save
         pop
sleep:   self
         then :sleepit

# Given an event Hash on the stack. Registers it as waitlist. Unschedule the
# current prog for continuation at :react.
listen:  self                       # [ events, Prog ]
         flip                       # [ Prog, events ]
         set  :waitlist             # [ Prog ]
         push :react                # [ Prog, :react ]
         set  :pc                   # [ Prog ]
         then :sleepit

# Given an event on the stack. Get the current Prog. Check if it waits for this
# particular event. If yes, schedule the Prog as specified in its wait list.
# Otherwise, return to sleep.
react:   self                       # [ event, Prog ]
         getr :waitlist             # [ event, waitlist ]
         flip                       # [ waitlist, event ]
         getr                       # [ pc/nil ]
         ifenil                     # ...
         then :sleep
         then :schedat
