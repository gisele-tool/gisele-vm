# Start expects a label on top of the stack. It forks a new child process and schedules
# it for running at that label
start:   fork
         save
         pop

# Run starts running the current prog at its program counter.
run:     self
         get :pc
         then                       # enqueue instruction at program counter
         get :input
         flip                       # [ Prog, [ input... ] ] -> [ [ input... ], Prog ]
         push []
         set :input
         save
         pop
         unfold                     # [ input... ]

# Resume expects an input array on the stack. It fetches the current Prog and schedules
# it with the given input
resume:  self                       # take the current Prog
         schedule                   # schedule it
         flip                       # [ input, prog ] -> [ prog, input ]
         set :input                 # prog.input = input
         save
         pop

# Puts the current Prog on the stack. Unschedules and saves it.
sleepit: unschedule
         save
         pop
sleep:   self
         then :sleepit

# Given an event Hash on the stack. Registers it as waitlist. Unschedule the
# current prog for continuation at :react.
listen:  self                       # take the current Prog
         flip                       #
         set  :waitlist             # events Hash as waitlist
         push :react                #
         set  :pc                   # program counter to :wakeup
         unschedule                 #
         save                       # progress to false
         pop

# Given an event on the stack.
react:   self                       # [ event, Prog ]
         get :waitlist              # [ event, Prog, waitlist ]
         flip                       # [ event, waitlist, Prog ]
         pop                        # [ event, waitlist ]
         flip                       # [ waitlist, event ]
         get                        # [ wailist, pc/nil ]
         flip                       # [ pc/nil, wailist ]
         pop                        # [ pc/nil ]
         ifenil
         then :sleep
         then :schedat

# Given a label on the stack, schedule the current Prog for execution there.
# The effective execution will only take place when the Prog will be selected
# for running.
schedat: self                       # [ pc, Prog ]
         flip                       # [ Prog, pc ]
         set :pc                    # [ Prog ]
         schedule                   # [ Prog ]
         push {}                    # [ Prog, {} ]
         set :waitlist              # [ Prog ]
         save                       # [ puid ]
         pop                        # [ ]
