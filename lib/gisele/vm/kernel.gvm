# Start expects a label on top of the stack. It forks a new child process and schedules
# it for running at that label
start:   fork
         save
         pop

# Run starts running the current prog at its program counter.
run:     self
         get :pc
         then                       # enqueue instruction at program counter
         get :input
         flip                       # [ Prog, [ input... ] ] -> [ [ input... ], Prog ]
         push []
         set :input
         save
         pop
         unfold                     # [ input... ]

# Resume expects an input array on the stack. It fetches the current Prog and schedules
# it with the given input
resume:  self                       # take the current Prog
         schedule                   # schedule it
         flip                       # [ input, prog ] -> [ prog, input ]
         set :input                 # prog.input = input
         save
         pop

# Given a label on the stack, schedule the current Prog for execution there.
# The effective execution will only take place when the Prog will be selected
# for running.
schedat: self                       # [ pc, Prog ]
         flip                       # [ Prog, pc ]
         set :pc                    # [ Prog ]
         schedule                   # [ Prog ]
         push {}                    # [ Prog, {} ]
         set :waitlist              # [ Prog ]
         save                       # [ puid ]
         pop                        # [ ]

# Puts the current Prog on the stack. Unschedules and saves it.
sleepit: unschedule
         save
         pop
sleep:   self
         then :sleepit

# Given an event Hash on the stack. Registers it as waitlist. Unschedule the
# current prog for continuation at :react.
listen:  self                       # [ events, Prog ]
         flip                       # [ Prog, events ]
         set  :waitlist             # [ Prog ]
         push :react                # [ Prog, :react ]
         set  :pc                   # [ Prog ]
         then :sleepit

# Given an event on the stack. Get the current Prog. Check if it waits for this
# particular event. If yes, schedule the Prog as specified in its wait list.
# Otherwise, return to sleep.
react:   self                       # [ event, Prog ]
         getr :waitlist             # [ event, waitlist ]
         flip                       # [ waitlist, event ]
         getr                       # [ pc/nil ]
         ifenil                     # ...
         then :sleep
         then :schedat

# Expects a label `joinat` and an array `forkat` of labels on the stack. Fork one
# child for each label in `forkat` and save them. Wait for forked children at `at`.
#                                   # [ joinat, [ forkat... ] ]
fork:    forka                      # [ joinat, [ Prog, ... ] ]
         savea                      # [ joinat, [ puid, ... ] ]
         self                       # [ joinat, [ puid, ... ], Prog ]
         flip                       # [ joinat, Prog, [ puid, ... ] ]
         set :waitlist              # [ joinat, Prog ]
         flip                       # [ Prog, joinat ]
         set :pc                    # [ Prog ]
         then :sleepit

# Expects an Hash `evt` of events. If the waitlist of the current prog is empty,
# schedule execution at `wake` in this event map. Otherwise simply returns asleep.
#                                   # [ {evt...} ]
join:    self                       # [ {evt...}, Prog ]
         getr :waitlist             # [ {evt...}, waitlist ]
         push []
         send :size                 # [ {evt...}, size ]
         ifezero
         push :wake
         push :wait                 # [ {evt...}, size, wake/wait ]
         flip                       # [ {evt...}, wake/wait, size ]
         pop                        # [ {evt...}, wake/wait ]
         get                        # [ {evt...}, label/nil ]
         flip                       # [ label/nil, {evt...} ]
         pop                        # [ label/nil ]
         ifenil                     # ...
         then :sleep
         then :schedat

# End the current Prog. Remove its puid from the parent waitlist and schedules the
# later.
#                                   # [ ]
notify:  parent                     # [ Prog ]
         get :waitlist              # [ Prog, waitlist ]
         end                        # [ Prog, waitlist, Prog ]
         save                       # [ Prog, waitlist, puid ]
         del                        # [ Prog, waitlist ]
         set :waitlist              # [ Prog ]
         schedule                   # [ Prog ]
         save                       # [ puid ]
         pop
